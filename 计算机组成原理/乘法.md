> 机器码中看到的 `,` 是用来区分符号位和数值位的，并不实际意义

二进制的乘法运算和十进制乘法运算是一样的，都是采用：**被乘数绝对值和乘数绝对值的每位相乘，然后错位相加**

`[x]原 = 1.1101，[y]原 = 0.1011`
  - 1.1101 × 0.1011 = 1.10001111
    - 0.1101 × 0.0001 = 0.00001101
    - 0.1101 × 0.001 = 0.0001101
    - 0.1101 × 0.00 = 0.000000
    - 0.1101 × 0.1 = 0.01101
  - 错位相加：0.00001101 + 0.0001101 + 0.000000 + 0.01101 = 0.10001111
  - 符号位进行异或运算：1 ⊕ 0 = 1
  - 最终结果：1.10001111

这个是我们人类通过竖式计算得到出结果，那么计算机要怎么实现这个步骤呢？难道也是像人类一样，被乘数和乘数每位相乘，然后在错位相加？

这样做的话，乘数有多少位，就需要多少个寄存器，这就增加了硬件成本。

那计算机该如何实现乘法呢？

通过前面的学习，我们知道运算器是由 `ACC` 、`MQ`、`X`、`ALU` 组成。

`ALU` 是运算器的核心，计算的功能是由这部分它来完成的。`ACC` 、`MQ`、`X`，它们是用来暂存操作和中间结果，通过指令交由 `ALU` 处理。

在乘法运算中，各寄存器有各种不同的作用：
  - `ACC`：乘积高位
  - `MQ`：乘数，乘积低位
  - `X`：被乘数

## 原码一位乘法

原码的一位乘法最终的运算结果是：`ACC + MQ`，运算结果的符号位在 `ACC` 符号位后(隐含位置)。

### 运算过程

在原码的一位乘法中，进行 `n` 轮加法和移位
  - 每次加法可能是 `+0` 或 `+[|x|]原`，需要根据 `MQ` 最后一位来判断
    - `MQ` 最低位是 `1`，则 `(ACC) + [|x|]原`
    - `MQ` 最低位是 `0`，则 `(ACC) + 0`
  - 每次移位是逻辑右移
  - `MQ` 最后一位是符号位的话不参与运算（到此运算结束）
  - 运算结果的符号位：**被乘数和乘数的符号位进行异或运算**
  - 运算结果数值位：`ACC + MQ`

### 计算步骤
|步骤|操作|ACC|MQ|X|
|:--|:--|:--|:--|:--|
|1|ACC 置 0|0,0000|0,1011|0,1101|
|2|MQ 末尾是 1，ACC + X = 00000 + 01101|0,1101|0,1011|0,1101|
|3|逻辑右移一位|0,0110|10,101|0,1101|
|4|MQ 末尾是 1，ACC + X = 00110 + 01101|1,0011|10,101|0,1101|
|5|逻辑右移一位|0,1001|110,10|0,1101|
|6|MQ 末尾是 0，ACC + 0 = 01001 + 0|0,1001|110,10|0,1101|
|7|逻辑右移一位|0,0100|1110,1|0,1101|
|8|MQ 末尾是 1，ACC + X = 00100 + 01101|1,0001|1110,1|0,1101|
|9|逻辑右移一位，MQ 最后一位是符号位，运算结束|0,1000|11110,|0,1101|
|10|最终符号：被乘数符号位 ⊕ 乘数符号位 = 1 ⊕ 0 = 1|-|-|-|

第9步，右移一位后，符号位移动到最后了，在原码的一位乘法中，最后一位符号位是不参与运算的。

所以最终的结果是 `1.10001111`


## 补码一位乘法

补码的一位乘法中 `MQ` 需要使用到辅助位，所以在最后一位补 `0`(称为辅助位，原本的最后一位称为最低位)
  - `ACC` 在高位补 `0`
  - `X` 在高位补充一位符号位（符号位是 `0` 补 `0`，是 `1` 补 `1`）

它的最终运算结果是 `ACC + MQ 符号位前的值`，运算结果的符号就是 `ACC` 最终结果的符号位。

### 运算过程

在补码的一位乘法中，进行 `n` 轮加法和移位
  - 每次加法可能是 `+0` 或 `+[x]补` 或 `+[-x]补`，需要根据 `MQ` 最后两个来判断
    - `MQ` 的最后一位称为辅助位，最后第二位称为最低位
    - 辅助位 - 最低位 = `1` 时，则 `(ACC) + [x]补`
    - 辅助位 - 最低位 = `0` 时，则 `(ACC) + 0`
    - 辅助位 - 最低位 = `-1` 时，则 `(ACC) + [-x]补`
  - 每次移位是算术右移
    - `ACC` 中符号位不参与移位，`MQ` 中符号参与移位
    - `ACC` 中正数右移，数值位补 `0`；负数右移，数值位补 `1`(符号位是啥就是啥)
  - `MQ` 最后一位是符号位也会参与运算
  - 运算结果的符号位：`ACC` 中最终结果的符号位
  - 运算结果：`ACC + MQ 符号位前的值`

### 计算步骤

在计算之前，需要先准备好被乘数的补码：`[x]补 = 11.0011`，`[-x]补 = 00.1101`

|步骤|操作|ACC|MQ|X|
|:--|:--|:--|:--|:--|
|1|ACC 置 0|00,0000|0,10110|11,0011|
|2|MQ(辅助位 - 最低位) = 0 - 1 = -1，ACC + [-x]补 = 000000 + 001101|00,1101|0,10110|11,0011|
|3|算术右移一位|00,0110|10,1011|11,0011|
|4|MQ(辅助位 - 最低位) = 1 - 1 = 0，ACC + 0 = 000110 + 000000|00,0110|10,1011|11,0011|
|5|算术右移一位|00,0011|010,101|11,0011|
|6|MQ(辅助位 - 最低位) = 1 - 0 = 1，ACC + [x]补 = 000011 + 11.0011|11,0110|010,101|11,0011|
|7|算术右移一位|11,1011|0010,10|11,0011|
|8|MQ(辅助位 - 最低位) = 0 - 1 = -1，ACC + [-x]补 = 11,1011 + 001101|00,1000|0010,10|11,0011|
|9|算术右移一位|00,0100|00010,1|11,0011|
|10|MQ(辅助位 - 最低位) = 1 - 0 = 1，ACC + [x]补 = 00,0100 + 110011|11,0111|00010,1|11,0011|
|11|最终符号：ACC 中的符号位：1|-|-|-|

相比于原码的一位乘法，补码的一位乘法在第九步算术右移后，符号位也要参与运算，也是说比原码的一位乘法多一步加法操作

所以最终的结果是：`1.01110001`

## 总结

补码的一位乘法运算过程比原码的运算过程多一步加法运算。

假如说数值位是 `4`，原码的一位乘法逻辑右移 `4` 次，做 `4` 次加法运算；补码的一位乘法算术右移 `4`，做 `5` 次加法运算。

也就是说原码的一位乘法进行 `n` 次右移，`n` 次加法，补码的一位乘法进行 `n` 次右移，`n + 1` 次加法。